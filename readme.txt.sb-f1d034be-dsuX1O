{\rtf1\ansi\ansicpg950\cocoartf1348\cocoasubrtf170
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs24 \cf0 Usage:\
1. Put the dataset into AVL file you downloaded\
2. Open command prompt\
3. cd to the AVL file\
4. Input: \
	AVL.exe \'93./ops-half.txt\'94\
5. If the exe file cannot run properly due to the compatibility problem of window system,\
    please try to input:\
	python AVL.py \'93./ops-half.txt\'94\
The python version I used is 2.7\
\
Background:\
1. The algorithm I constructed is AVL tree. It is efficient in querying, but insertion and deletion are costly because of the rotation applied.\
\
2. The dataset contains only 50 queries and 500,000 insertions. As the query distributed randomly in the dataset, we cannot perform querying after all of the insertion.\
\
3. Doing the insertion one by one is very costly because we probably have to implement rebalancing for every insertion.\
\
4. In order to improve the algorithms, I decided not to use rotation to manage the tree.\
\
\
Steps:\
1. Append the number to array when encountering \'93ins\'94 command.\
2. Do the step 1 repeatedly until we meet \'93qry\'94 command.\
3. Sort that array by quick sort algorithm.\
4. Convert the sorted array into AVL tree. This step is easy, just applying the characteristics of linked list. The time complexity for this step is n.\
5. Empty the sorted array.\
5. Append the AVL tree to a specific array which used to stored AVL tree.\
6. Query the number by searching the AVL trees in the AVL tree array.\
7. If do it properly, it should return one number in the first query, two numbers in the second query, and so on. \
8. The predecessor of the query number should be the largest one in the returned value.\
8. Keep repeating Step 1 to Step 9 until all of the insertions and queries are done.\
\
Advance version:\
1. In step 2, we stop appending the array until we meet query request. \
2. The appending action can be stopped earlier. For example, stop appending after 500 numbers were added. \
3. More tree would be constructed. \
4. Time can be saved in sorting process. \
5. One AVL tree should not contain too few nodes. Otherwise, it would backfire us in searching process. We would lose the query advantage.\
\
P.S. The 500,000 ins and 50 qry can be done in 4 - 8 seconds. \
As I am using quick sort, it can finish it within 5 seconds if being lucky.\
P.S.2. It used around 95 seconds to process all of the actions if the original AVL tree (with rotation) applied.}